module.exports = [
    {
        "id": 0,
        "isRead": false,
        "subject": "Anatomy of an HTTP Transaction",
        "body": "<p>The purpose of this guide is to impart a solid understanding of the process of<br />Node.js HTTP handling. We&#39;ll assume that you know, in a general sense, how HTTP<br />requests work, regardless of language or programming environment. We&#39;ll also<br />assume a bit of familiarity with Node.js [<code>EventEmitters</code>][] and [<code>Streams</code>][].<br />If you&#39;re not quite familiar with them, it&#39;s worth taking a quick read through<br />the API docs for each of those.</p><br />"
    },
    {
        "id": 1,
        "isRead": false,
        "subject": "Create the Server",
        "body": "<p>Any node web server application will at some point have to create a web server<br />object. This is done by using [<code>createServer</code>][].</p><br /><pre><code class=\"lang-javascript\">var http = require(&#39;http&#39;);<br /><br />var server = http.createServer(function(request, response) {<br />  // magic happens here!<br />});<br /></code></pre><br /><p>The function that&#39;s passed in to [<code>createServer</code>][] is called once for every<br />HTTP request that&#39;s made against that server, so it&#39;s called the request<br />handler. In fact, the [<code>Server</code>][] object returned by [<code>createServer</code>][] is an<br />[<code>EventEmitter</code>][], and what we have here is just shorthand for creating a<br /><code>server</code> object and then adding the listener later.</p><br /><pre><code class=\"lang-javascript\">var server = http.createServer();<br />server.on(&#39;request&#39;, function(request, response) {<br />  // the same kind of magic happens here!<br />});<br /></code></pre><br /><p>When an HTTP request hits the server, node calls the request handler function<br />with a few handy objects for dealing with the transaction, <code>request</code> and<br /><code>response</code>. We&#39;ll get to those shortly.</p><br /><p>In order to actually serve requests, the [<code>listen</code>][] method needs to be called<br />on the <code>server</code> object. In most cases, all you&#39;ll need to pass to <code>listen</code> is<br />the port number you want the server to listen on. There are some other options<br />too, so consult the [API reference][].</p><br />"
    },
    {
        "id": 2,
        "isRead": false,
        "subject": "Method, URL and Headers",
        "body": "<p>When handling a request, the first thing you&#39;ll probably want to do is look at<br />the method and URL, so that appropriate actions can be taken. Node makes this<br />relatively painless by putting handy properties onto the <code>request</code> object.</p><br /><pre><code class=\"lang-javascript\">var method = request.method;<br />var url = request.url;<br /></code></pre><br /><blockquote><br /><p><strong>Note:</strong> The <code>request</code> object is an instance of [<code>IncomingMessage</code>][].</p><br /></blockquote><br /><p>The <code>method</code> here will always be a normal HTTP method/verb. The <code>url</code> is the<br />full URL without the server, protocol or port. For a typical URL, this means<br />everything after and including the third forward slash.</p><br /><p>Headers are also not far away. They&#39;re in their own object on <code>request</code> called<br /><code>headers</code>.</p><br /><pre><code class=\"lang-javascript\">var headers = request.headers;<br />var userAgent = headers[&#39;user-agent&#39;];<br /></code></pre><br /><p>It&#39;s important to note here that all headers are represented in lower-case only,<br />regardless of how the client actually sent them. This simplifies the task of<br />parsing headers for whatever purpose.</p><br /><p>If some headers are repeated, then their values are overwritten or joined<br />together as comma-separated strings, depending on the header. In some cases,<br />this can be problematic, so [<code>rawHeaders</code>][] is also available.</p><br />"
    },
    {
        "id": 3,
        "isRead": false,
        "subject": "Request Body",
        "body": "<p>When receiving a <code>POST</code> or <code>PUT</code> request, the request body might be important to<br />your application. Getting at the body data is a little more involved than<br />accessing request headers. The <code>request</code> object that&#39;s passed in to a handler<br />implements the [<code>ReadableStream</code>][] interface. This stream can be listened to or<br />piped elsewhere just like any other stream. We can grab the data right out of<br />the stream by listening to the stream&#39;s <code>&#39;data&#39;</code> and <code>&#39;end&#39;</code> events.</p><br /><p>The chunk emitted in each <code>&#39;data&#39;</code> event is a [<code>Buffer</code>][]. If you know it&#39;s<br />going to be string data, the best thing to do is collect the data in an array,<br />then at the <code>&#39;end&#39;</code>, concatenate and stringify it.</p><br /><pre><code class=\"lang-javascript\">var body = [];<br />request.on(&#39;data&#39;, function(chunk) {<br />  body.push(chunk);<br />}).on(&#39;end&#39;, function() {<br />  body = Buffer.concat(body).toString();<br />  // at this point, `body` has the entire request body stored in it as a string<br />});<br /></code></pre><br /><blockquote><br /><p><strong>Note:</strong> This may seem a tad tedious, and in many cases, it is. Luckily,<br />there are modules like [<code>concat-stream</code>][] and [<code>body</code>][] on [<code>npm</code>][] which can<br />help hide away some of this logic. It&#39;s important to have a good understanding<br />of what&#39;s going on before going down that road, and that&#39;s why you&#39;re here!</p><br /></blockquote><br />"
    },
    {
        "id": 4,
        "isRead": false,
        "subject": "A Quick Thing About Errors",
        "body": "<p>Since the <code>request</code> object is a [<code>ReadableStream</code>][], it&#39;s also an<br />[<code>EventEmitter</code>][] and behaves like one when an error happens.</p><br /><p>An error in the <code>request</code> stream presents itself by emitting an <code>&#39;error&#39;</code> event<br />on the stream. <strong>If you don&#39;t have a listener for that event, the error will be<br /><em>thrown</em>, which could crash your Node.js program.</strong> You should therefore add an<br /><code>&#39;error&#39;</code> listener on your request streams, even if you just log it and<br />continue on your way. (Though it&#39;s probably best to send some kind of HTTP error<br />response. More on that later.)</p><br /><pre><code class=\"lang-javascript\">request.on(&#39;error&#39;, function(err) {<br />  // This prints the error message and stack trace to `stderr`.<br />  console.error(err.stack);<br />});<br /></code></pre><br /><p>There are other ways of [handling these errors][] such as<br />other abstractions and tools, but always be aware that errors can and do happen,<br />and you&#39;re going to have to deal with them.</p><br />"
    },
    {
        "id": 5,
        "isRead": false,
        "subject": "What We've Got so Far",
        "body": "<p>At this point, we&#39;ve covered creating a server, and grabbing the method, URL,<br />headers and body out of requests. When we put that all together, it might look<br />something like this:</p><br /><pre><code class=\"lang-javascript\">var http = require(&#39;http&#39;);<br /><br />http.createServer(function(request, response) {<br />  var headers = request.headers;<br />  var method = request.method;<br />  var url = request.url;<br />  var body = [];<br />  request.on(&#39;error&#39;, function(err) {<br />    console.error(err);<br />  }).on(&#39;data&#39;, function(chunk) {<br />    body.push(chunk);<br />  }).on(&#39;end&#39;, function() {<br />    body = Buffer.concat(body).toString();<br />    // At this point, we have the headers, method, url and body, and can now<br />    // do whatever we need to in order to respond to this request.<br />  });<br />}).listen(8080); // Activates this server, listening on port 8080.<br /></code></pre><br /><p>If we run this example, we&#39;ll be able to <em>receive</em> requests, but not <em>respond</em><br />to them. In fact, if you hit this example in a web browser, your request would<br />time out, as nothing is being sent back to the client.</p><br /><p>So far we haven&#39;t touched on the <code>response</code> object at all, which is an instance<br />of [<code>ServerResponse</code>][], which is a [<code>WritableStream</code>][]. It contains many<br />useful methods for sending data back to the client. We&#39;ll cover that next.</p><br />"
    },
    {
        "id": 6,
        "isRead": false,
        "subject": "HTTP Status Code",
        "body": "<p>If you don&#39;t bother setting it, the HTTP status code on a response will always<br />be 200. Of course, not every HTTP response warrants this, and at some point<br />you&#39;ll definitely want to send a different status code. To do that, you can set<br />the <code>statusCode</code> property.</p><br /><pre><code class=\"lang-javascript\">response.statusCode = 404; // Tell the client that the resource wasn&#39;t found.<br /></code></pre><br /><p>There are some other shortcuts to this, as we&#39;ll see soon.</p><br />"
    },
    {
        "id": 7,
        "isRead": false,
        "subject": "Setting Response Headers",
        "body": "<p>Headers are set through a convenient method called [<code>setHeader</code>][].</p><br /><pre><code class=\"lang-javascript\">response.setHeader(&#39;Content-Type&#39;, &#39;application/json&#39;);<br />response.setHeader(&#39;X-Powered-By&#39;, &#39;bacon&#39;);<br /></code></pre><br /><p>When setting the headers on a response, the case is insensitive on their names.<br />If you set a header repeatedly, the last value you set is the value that gets<br />sent.</p><br />"
    },
    {
        "id": 8,
        "isRead": false,
        "subject": "Explicitly Sending Header Data",
        "body": "<p>The methods of setting the headers and status code that we&#39;ve already discussed<br />assume that you&#39;re using &quot;implicit headers&quot;. This means you&#39;re counting on node<br />to send the headers for you at the correct time before you start sending body<br />data.</p><br /><p>If you want, you can <em>explicitly</em> write the headers to the response stream.<br />To do this, there&#39;s a method called [<code>writeHead</code>][], which writes the status<br />code and the headers to the stream.</p><br /><pre><code class=\"lang-javascript\">response.writeHead(200, {<br />  &#39;Content-Type&#39;: &#39;application/json&#39;,<br />  &#39;X-Powered-By&#39;: &#39;bacon&#39;<br />});<br /></code></pre><br /><p>Once you&#39;ve set the headers (either implicitly or explicitly), you&#39;re ready to<br />start sending response data.</p><br />"
    },
    {
        "id": 9,
        "isRead": false,
        "subject": "Sending Response Body",
        "body": "<p>Since the <code>response</code> object is a [<code>WritableStream</code>][], writing a response body<br />out to the client is just a matter of using the usual stream methods.</p><br /><pre><code class=\"lang-javascript\">response.write(&#39;&lt;html&gt;&#39;);<br />response.write(&#39;&lt;body&gt;&#39;);<br />response.write(&#39;&lt;h1&gt;Hello, World!&lt;/h1&gt;&#39;);<br />response.write(&#39;&lt;/body&gt;&#39;);<br />response.write(&#39;&lt;/html&gt;&#39;);<br />response.end();<br /></code></pre><br /><p>The <code>end</code> function on streams can also take in some optional data to send as the<br />last bit of data on the stream, so we can simplify the example above as follows.</p><br /><pre><code class=\"lang-javascript\">response.end(&#39;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello, World!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&#39;);<br /></code></pre><br /><blockquote><br /><p><strong>Note:</strong> It&#39;s important to set the status and headers <em>before</em> you start<br />writing chunks of data to the body. This makes sense, since headers come before<br />the body in HTTP responses.</p><br /></blockquote><br />"
    },
    {
        "id": 10,
        "isRead": false,
        "subject": "Another Quick Thing About Errors",
        "body": "<p>The <code>response</code> stream can also emit <code>&#39;error&#39;</code> events, and at some point you&#39;re<br />going to have to deal with that as well. All of the advice for <code>request</code> stream<br />errors still applies here.</p><br />"
    },
    {
        "id": 11,
        "isRead": false,
        "subject": "Put It All Together",
        "body": "<p>Now that we&#39;ve learned about making HTTP responses, let&#39;s put it all together.<br />Building on the earlier example, we&#39;re going to make a server that sends back<br />all of the data that was sent to us by the user. We&#39;ll format that data as JSON<br />using <code>JSON.stringify</code>.</p><br /><pre><code class=\"lang-javascript\"><br />var http = require(&#39;http&#39;);<br /><br />http.createServer(function(request, response) {<br />  var headers = request.headers;<br />  var method = request.method;<br />  var url = request.url;<br />  var body = [];<br />  request.on(&#39;error&#39;, function(err) {<br />    console.error(err);<br />  }).on(&#39;data&#39;, function(chunk) {<br />    body.push(chunk);<br />  }).on(&#39;end&#39;, function() {<br />    body = Buffer.concat(body).toString();<br />    // BEGINNING OF NEW STUFF<br /><br />    response.on(&#39;error&#39;, function(err) {<br />      console.error(err);<br />    });<br /><br />    response.statusCode = 200;<br />    response.setHeader(&#39;Content-Type&#39;, &#39;application/json&#39;);<br />    // Note: the 2 lines above could be replaced with this next one:<br />    // response.writeHead(200, {&#39;Content-Type&#39;: &#39;application/json&#39;})<br /><br />    var responseBody = {<br />      headers: headers,<br />      method: method,<br />      url: url,<br />      body: body<br />    };<br /><br />    response.write(JSON.stringify(responseBody));<br />    response.end();<br />    // Note: the 2 lines above could be replaced with this next one:<br />    // response.end(JSON.stringify(responseBody))<br /><br />    // END OF NEW STUFF<br />  });<br />}).listen(8080);<br /></code></pre><br />"
    },
    {
        "id": 12,
        "isRead": false,
        "subject": "Echo Server Example",
        "body": "<p>Let&#39;s simplify the previous example to make a simple echo server, which just<br />sends whatever data is received in the request right back in the response. All<br />we need to do is grab the data from the request stream and write that data to<br />the response stream, similar to what we did previously.</p><br /><pre><code class=\"lang-javascript\">var http = require(&#39;http&#39;);<br /><br />http.createServer(function(request, response) {<br />  var body = [];<br />  request.on(&#39;data&#39;, function(chunk) {<br />    body.push(chunk);<br />  }).on(&#39;end&#39;, function() {<br />    body = Buffer.concat(body).toString();<br />    response.end(body);<br />  });<br />}).listen(8080);<br /></code></pre><br /><p>Now let&#39;s tweak this. We want to only send an echo under the following<br />conditions:</p><br /><ul><br /><li>The request method is GET.</li><br /><li>The URL is <code>/echo</code>.</li><br /></ul><br /><p>In any other case, we want to simply respond with a 404.</p><br /><pre><code class=\"lang-javascript\">var http = require(&#39;http&#39;);<br /><br />http.createServer(function(request, response) {<br />  if (request.method === &#39;GET&#39; &amp;&amp; request.url === &#39;/echo&#39;) {<br />    var body = [];<br />    request.on(&#39;data&#39;, function(chunk) {<br />      body.push(chunk);<br />    }).on(&#39;end&#39;, function() {<br />      body = Buffer.concat(body).toString();<br />      response.end(body);<br />    })<br />  } else {<br />    response.statusCode = 404;<br />    response.end();<br />  }<br />}).listen(8080);<br /></code></pre><br /><blockquote><br /><p><strong>Note:</strong> By checking the URL in this way, we&#39;re doing a form of &quot;routing&quot;.<br />Other forms of routing can be as simple as <code>switch</code> statements or as complex as<br />whole frameworks like [<code>express</code>][]. If you&#39;re looking for something that does<br />routing and nothing else, try [<code>router</code>][].</p><br /></blockquote><br /><p>Great! Now let&#39;s take a stab at simplifying this. Remember, the <code>request</code> object<br />is a [<code>ReadableStream</code>][] and the <code>response</code> object is a [<code>WritableStream</code>][].<br />That means we can use [<code>pipe</code>][] to direct data from one to the other. That&#39;s<br />exactly what we want for an echo server!</p><br /><pre><code class=\"lang-javascript\">var http = require(&#39;http&#39;);<br /><br />http.createServer(function(request, response) {<br />  if (request.method === &#39;GET&#39; &amp;&amp; request.url === &#39;/echo&#39;) {<br />    request.pipe(response);<br />  } else {<br />    response.statusCode = 404;<br />    response.end();<br />  }<br />}).listen(8080);<br /></code></pre><br /><p>Yay streams!</p><br /><p>We&#39;re not quite done yet though. As mentioned multiple times in this guide,<br />errors can and do happen, and we need to deal with them.</p><br /><p>To handle errors on the request stream, we&#39;ll log the error to <code>stderr</code> and send<br />a 400 status code to indicate a <code>Bad Request</code>. In a real-world application,<br />though, we&#39;d want to inspect the error to figure out what the correct status code<br />and message would be. As usual with errors, you should consult the<br />[<code>Error</code> documentation][].</p><br /><p>On the response, we&#39;ll just log the error to <code>stdout</code>.</p><br /><pre><code class=\"lang-javascript\">var http = require(&#39;http&#39;);<br /><br />http.createServer(function(request, response) {<br />  request.on(&#39;error&#39;, function(err) {<br />    console.error(err);<br />    response.statusCode = 400;<br />    response.end();<br />  });<br />  response.on(&#39;error&#39;, function(err) {<br />    console.error(err);<br />  });<br />  if (request.method === &#39;GET&#39; &amp;&amp; request.url === &#39;/echo&#39;) {<br />    request.pipe(response);<br />  } else {<br />    response.statusCode = 404;<br />    response.end();<br />  }<br />}).listen(8080);<br /></code></pre><br /><p>We&#39;ve now covered most of the basics of handling HTTP requests. At this point,<br />you should be able to:</p><br /><ul><br /><li>Instantiate an HTTP server with a request handler function, and have it listen<br />on a port.</li><br /><li>Get headers, URL, method and body data from <code>request</code> objects.</li><br /><li>Make routing decisions based on URL and/or other data in <code>request</code> objects.</li><br /><li>Send headers, HTTP status codes and body data via <code>response</code> objects.</li><br /><li>Pipe data from <code>request</code> objects and to <code>response</code> objects.</li><br /><li>Handle stream errors in both the <code>request</code> and <code>response</code> streams.</li><br /></ul><br /><p>From these basics, Node.js HTTP servers for many typical use cases can be<br />constructed. There are plenty of other things these APIs provide, so be sure to<br />read through the API docs for [<code>EventEmitters</code>][], [<code>Streams</code>][], and [<code>HTTP</code>][].</p><br />"
    }
];
